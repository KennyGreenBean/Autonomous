#pragma config(Sensor, port7,  TouchLED,       sensorVexIQ_LED)
#pragma config(Sensor, port12, Gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor5,          LMotor,        tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor6,          Intake,        tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor8,          Cata2,         tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor9,          RMotor,        tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor10,         Cata1,         tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor11,         Intake2,       tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float g_gyroDriftingRate = 0;

void initGyro(){
	resetTimer(T1);
	resetGyro(Gyro);
	wait1Msec(3000);
	float driftedGyroDegrees = getGyroDegreesFloat(Gyro);
	g_gyroDriftingRate = driftedGyroDegrees / 3000;
}

float adjustedGyroFloat(){
	return getGyroDegreesFloat(Gyro) - g_gyroDriftingRate * getTimer(T1, milliseconds);
}


void resetChassisEncoder()
{
	resetMotorEncoder(LMotor);
	resetMotorEncoder(RMotor);
}

void setChassisSpeed(int leftSpeed, int rightSpeed)
{
	setMotorSpeed(LMotor, leftSpeed);
	setMotorSpeed(RMotor, rightSpeed);
}

float getChassisEncoder()
{
	return ((getMotorEncoder(LMotor)) + (getMotorEncoder(RMotor)/2));
}
//_____________________________________________________________________________________________________________________

void setIntake(int speed){
	setMotorSpeed(Intake, speed);
	setMotorSpeed(Intake2, speed);
}

void stopIntake(){
	stopMultipleMotors(Intake, Intake2);
}

void spinCata(int secondse){
	resetTimer(T1);
	while(getTimer(T1, seconds) < secondse){
		setMultipleMotors(100, Intake, Intake2);
		setMultipleMotors(100, Cata1, Cata2);
		if(getTouchLEDValue(TouchLED) == true){
			break;
		}
		wait1Msec(1000);
		setMultipleMotors(-100, Intake, Intake2);
		if(getTouchLEDValue(TouchLED) == true){
			break;
		}
		wait1Msec(300);
	}
	stopAllMotors();
}

//_____________________________________________________________________________________________________________________
/**
* @brief Move chassis based on steering value
*        steerig 0, move forward
*        +/- 0-50, smooth turn (2 wheel turn)
*        +/- 50, pivot turn
*        +/- 50-100, one positve, one negative 2 wheel turn (rarely used)
*        +/- 100, on spot turn
*        +, turning left
*        -, turning right
*
* @param steering Steering direction of the robot
* @param speed Moving speed of the robot
*/
void moveSteering(float steering, int speed)
{
	int leftSpeed;
	int rightSpeed;

	if (steering > 0) // turn left
	{
		leftSpeed = (steering * (-2) + 100) * speed / 100;
		rightSpeed = speed;
	}

	if(steering < 0) // turn right
	{
		leftSpeed = speed;
		rightSpeed = (steering * 2 + 100) * speed / 100;
	}

	if(steering == 0){ // go straight
		leftSpeed = speed;
		rightSpeed = speed;
	}

	setChassisSpeed(leftSpeed, rightSpeed);
}
//_____________________________________________________________________________________________________________________
/**
* @brief Turn the robot to target rotation
*
* @param heading Target rotation of the robot turning
* @param steering Steering value to be passed to moveSteering (see moveSteering for detailed explanation)
* @param speed Moving speed of the robot
* @param momentum Momentum value to stop the robot before it reaches target rotation
*/
void turn(int intakeSpeed, float heading, int steering, int speed, float decelRate, float decelZone)
{
	int minSpeed = 30;
	float currentSpeed = speed;
	resetGyro(Gyro);
	while (abs(adjustedGyroFloat()) < abs(heading)){
		setIntake(intakeSpeed);
		if(abs(adjustedGyroFloat()) > abs(heading) - abs(decelZone)){ //decel
			currentSpeed = currentSpeed * (1 - decelRate);
			if(abs(currentSpeed) < abs(minSpeed)){
				currentSpeed = abs(minSpeed);
			}
		}

		moveSteering(steering, currentSpeed);
	}
	setChassisSpeed(0, 0);
	stopIntake();
}
//_____________________________________________________________________________________________________________________
float integral = 0.0;
float previousError = 0.0;

float PIDController(float error, float kp, float ki, float kd, float dt)
{
	integral = integral + error * dt;
	float derivative = (error - previousError) / dt;
	float output = kp * error + ki * integral + kd * derivative;
	previousError = error;
	return output;
}



void goStraightPID(int IntakeSpeed, float heading, float speed, float distance, float kp, float ki, float kd, float accelRate, float decelRate, float decelZone)
{
	float error;
	float output;
	int dt = 20;
	integral = 0.0;
	previousError = 0.0;
	int minSpeed = 10;
	float currentSpeed = minSpeed;
	int direction = sgn(speed);

	int currentEncoder = 0;
	int lastEncoder = 0;
	long startingTime = nSysTime;
	// reset all encoders
	resetChassisEncoder();
	resetGyro(Gyro);

	while (abs(getChassisEncoder()) < abs(distance))
	{
		setIntake(IntakeSpeed);
		// P control of the robot direction
		error = heading - adjustedGyroFloat();
		output = PIDController(error, kp, ki, kd, dt);

		if(abs(getChassisEncoder()) > abs(distance) - abs(decelZone)){ //decel
			currentSpeed = currentSpeed * (1 - decelRate);
			if(abs(currentSpeed) < abs(minSpeed)){
				currentSpeed = abs(minSpeed) * direction;
			}
		}
		else if(abs(currentSpeed) < abs(speed)){//accel
			currentSpeed = currentSpeed * (1 + accelRate);
			if(abs(currentSpeed) > abs(speed)){
				currentSpeed = speed;
			}
		}

		moveSteering(output, currentSpeed);

		currentEncoder = getChassisEncoder();
		if((nSysTime - startingTime) > 500){
			if (abs((currentEncoder - lastEncoder)) < 1){
				playSound(soundSiren2);
				break;
			}
		}
		lastEncoder = currentEncoder;

		wait1Msec(dt);
	}
	setChassisSpeed(0,0);
	stopIntake();
}

void moveDistance(int intake, float distance, float speed){
	resetChassisEncoder();
	while (abs(getChassisEncoder()) < abs(distance)){
		setChassisSpeed(speed, speed);
		setIntake(intake);
	}
	stopAllMotors();
}

void moveSeconds(int intake, float secondsw, int speed){
	resetTimer(T1);
	float error;
	float heading;
	float output;

	while(getTimer(T1, seconds) < secondsw){
		setIntake(intake);
		error = heading - adjustedGyroFloat();
		output = PIDController(error, 1, 0, 0, 20);

		setChassisSpeed(speed, speed);
	}
	stopAllMotors();
}

/*
steerig 0, move forward
*        +/- 0-50, smooth turn (2 wheel turn)
*        +/- 50, pivot turn
*        +/- 50-100, one positve, one negative 2 wheel turn (rarely used)
*        +/- 100, on spot turn
*        +, turning left
*        -, turning right
*/
// (IntakeSpeed, heading, speed, distance, kp, ki, kd, accelRate, decelRate, decelZone)
// (IntakeSpeed, heading, steering, speed, decelRate, decelZone)

void leProgram(){
	turn(100, -10, 50, 70, 0, 0);
	goStraightPID(100, 0, 70, 300, 1, 0, 0, 0.1, 0, 0);
	goStraightPID(100, 0, -70, 400, 1, 0, 0, 0.1, 0, 0);

	turn(100, 10, -100, 70, 0, 0);
	goStraightPID(100, 0, 70, 300, 1, 0, 0, 0.1, 0, 0);
	goStraightPID(100, 0, -70, 100, 1, 0, 0, 0.1, 0, 0);

	turn(100, -10, 100, 40, 0, 0);
	moveSeconds(100, 0.5, -100);
	turn(100, -85, 60, 50, 0, 0);
	goStraightPID(100, 0, 100, 2300, 1, 0, 0, 0.1, 0, 0);
	moveDistance(100, 200, -70);

	turn(100, -55, -45, 100, 0, 0);
	goStraightPID(100, 0, 100, 2000, 1, 0, 0, 0.1, 0, 0);
	moveDistance(100, 100, -70);
	turn(100, 70, -60, 100, 0, 0);

	moveSeconds(100, 2, 100);
	moveDistance(100, 80, -50);
	turn(100, 80, 100, 40, 0.1, 40);
	moveSeconds(100, 0.8, 70);
	moveDistance(100, 150, -30);
	spinCata(30);
}

void leProgram2(){
	goStraightPID(100, 0, 100, 2300, 1, 0, 0, 0.1, 0, 0);
	moveDistance(100, 200, -70);

	turn(100, -55, -45, 100, 0, 0);
	goStraightPID(100, 0, 100, 2000, 1, 0, 0, 0.1, 0, 0);
	moveDistance(100, 100, -70);
	turn(100, 70, -60, 100, 0, 0);

	moveSeconds(100, 2, 100);
	moveDistance(100, 150, -50);
	turn(100, 65, 100, 40, 0.1, 40);
	moveSeconds(100, 0.8, 70);
	moveDistance(100, 180, -30);
	spinCata(30);
}

/*goStraightPID(100, 0, 100, 900, 1, 0,0, 0.1, 0, 0);
turn(100, -80, -45, 100, 0, 0);
goStraightPID(100, 0, 100, 1800, 1, 0, 0, 0.1, 0, 0);
goBackward(100, -70);
intakeSpin(1, 100);
stopAllMotors();
intakeSpin(0.4, -100);
goBackward(200, -70);
turn(0, 50, -45, 100, 0, 0);
goStraightPID(0, 0, 70, 400, 1, 0, 0, 0.1, 0, 0);
goBackward(240, -50);
turn(0, -40, 100, 100, 0.2, 70);
setChassisSpeed(100, 100);
wait1Msec(600);
stopAllMotors();
setChassisSpeed(-70, -70);
wait1Msec(700);
stopAllMotors();
spinCata();
*/

//_____________________________________________________________________________________________________________________
task main()
{

	setTouchLEDColor(port7, colorBlue);
	waitUntil(getTouchLEDValue(TouchLED) == 1);
	stopAllMotors();
	setTouchLEDColor(port7, colorRed);
	initGyro();
	setTouchLEDColor(port7, colorGreen);
	waitUntil(getTouchLEDValue(TouchLED) == 1);
	resetGyro(Gyro);

	//___________________________________________________________________________________________

	leProgram();
	stopAllMotors();
	wait1Msec(1000);
	//_____________________________________________________________________
	setTouchLEDColor(port7, colorBlue);
	waitUntil(getTouchLEDValue(TouchLED) == 1);
	//_____________________________________________________________________

	leProgram2();
	stopAllMotors();
	wait1Msec(1000);

	setTouchLEDColor(port7, colorRed);
	waitUntil(getTouchLEDValue(TouchLED) == 1);
	resetTimer(T1);
	while(getTimer(T1, seconds) <= 5){
		setChassisSpeed(-100, -100);
		wait1Msec(500);
		if(getTouchLEDValue(TouchLED) == true){
			break;
		}
	}
	stopAllMotors();
}
